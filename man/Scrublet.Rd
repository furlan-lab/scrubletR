% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/scrubletR.R
\name{Scrublet}
\alias{Scrublet}
\title{Scrublet R6 Class}
\description{
Scrublet R6 Class

Scrublet R6 Class
}
\seealso{
\code{\link{tot_counts_norm}}
Identify highly variable genes expressed above a minimum level
}
\section{Methods}{
\subsection{Public methods}{
\itemize{
\item \href{#method-Scrublet-get_dims}{\code{Scrublet$get_dims()}}
\item \href{#method-Scrublet-new}{\code{Scrublet$new()}}
\item \href{#method-Scrublet-scrub_doublets}{\code{Scrublet$scrub_doublets()}}
\item \href{#method-Scrublet-simulate_doublets}{\code{Scrublet$simulate_doublets()}}
\item \href{#method-Scrublet-set_manifold}{\code{Scrublet$set_manifold()}}
\item \href{#method-Scrublet-calculate_doublet_scores}{\code{Scrublet$calculate_doublet_scores()}}
\item \href{#method-Scrublet-call_doublets}{\code{Scrublet$call_doublets()}}
\item \href{#method-Scrublet-nearest_neighbor_classifier}{\code{Scrublet$nearest_neighbor_classifier()}}
\item \href{#method-Scrublet-plot_histogram}{\code{Scrublet$plot_histogram()}}
\item \href{#method-Scrublet-set_embedding}{\code{Scrublet$set_embedding()}}
\item \href{#method-Scrublet-plot_embedding}{\code{Scrublet$plot_embedding()}}
\item \href{#method-Scrublet-pipeline_normalize}{\code{Scrublet$pipeline_normalize()}}
\item \href{#method-Scrublet-pipeline_get_gene_filter}{\code{Scrublet$pipeline_get_gene_filter()}}
\item \href{#method-Scrublet-pipeline_apply_gene_filter}{\code{Scrublet$pipeline_apply_gene_filter()}}
\item \href{#method-Scrublet-pipeline_mean_center}{\code{Scrublet$pipeline_mean_center()}}
\item \href{#method-Scrublet-pipeline_normalize_variance}{\code{Scrublet$pipeline_normalize_variance()}}
\item \href{#method-Scrublet-pipeline_zscore}{\code{Scrublet$pipeline_zscore()}}
\item \href{#method-Scrublet-pipeline_log_transform}{\code{Scrublet$pipeline_log_transform()}}
\item \href{#method-Scrublet-pipeline_truncated_svd}{\code{Scrublet$pipeline_truncated_svd()}}
\item \href{#method-Scrublet-pipeline_pca}{\code{Scrublet$pipeline_pca()}}
\item \href{#method-Scrublet-clone}{\code{Scrublet$clone()}}
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-get_dims"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-get_dims}{}}}
\subsection{Method \code{get_dims()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$get_dims()}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-new"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-new}{}}}
\subsection{Method \code{new()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$new(
  counts_matrix,
  total_counts = NULL,
  sim_doublet_ratio = 2,
  n_neighbors = NULL,
  expected_doublet_rate = 0.1,
  stdev_doublet_rate = 0.02,
  random_state = 0
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-scrub_doublets"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-scrub_doublets}{}}}
\subsection{Method \code{scrub_doublets()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$scrub_doublets(
  synthetic_doublet_umi_subsampling = 1,
  use_approx_neighbors = TRUE,
  distance_metric = "euclidean",
  get_doublet_neighbor_parents = FALSE,
  min_counts = 3,
  min_cells = 3,
  min_gene_variability_pctl = 85,
  log_transform = FALSE,
  mean_center = T,
  normalize_variance = T,
  n_prin_comps = 30,
  svd_solver = "arpack",
  verbose = TRUE
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-simulate_doublets"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-simulate_doublets}{}}}
\subsection{Method \code{simulate_doublets()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$simulate_doublets(
  sim_doublet_ratio = NULL,
  synthetic_doublet_umi_subsampling = 1
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-set_manifold"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-set_manifold}{}}}
\subsection{Method \code{set_manifold()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$set_manifold(manifold_obs, manifold_sim)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-calculate_doublet_scores"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-calculate_doublet_scores}{}}}
\subsection{Method \code{calculate_doublet_scores()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$calculate_doublet_scores(
  use_approx_neighbors = TRUE,
  distance_metric = "euclidean",
  get_doublet_neighbor_parents = FALSE
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-call_doublets"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-call_doublets}{}}}
\subsection{Method \code{call_doublets()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$call_doublets(self, threshold = NULL, verbose = TRUE)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-nearest_neighbor_classifier"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-nearest_neighbor_classifier}{}}}
\subsection{Method \code{nearest_neighbor_classifier()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$nearest_neighbor_classifier(
  k = 40,
  use_approx_nn = TRUE,
  distance_metric = "euclidean",
  exp_doub_rate = 0.1,
  stdev_doub_rate = 0.03,
  get_neighbor_parents = FALSE
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{k}}{Number of nearest neighbors.}

\item{\code{use_approx_nn}}{Whether to use approximate nearest neighbors.}

\item{\code{distance_metric}}{Distance metric for finding neighbors.}

\item{\code{exp_doub_rate}}{Expected doublet rate.}

\item{\code{stdev_doub_rate}}{Standard deviation of doublet rate.}

\item{\code{get_neighbor_parents}}{Whether to get parents of doublet neighbors.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL (modifies the R6 object in place)
Total Counts Normalization

This function performs total counts normalization on the observed and simulated expression matrices.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-plot_histogram"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-plot_histogram}{}}}
\subsection{Method \code{plot_histogram()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$plot_histogram(
  scale_hist_obs = "log",
  scale_hist_sim = "linear",
  fig_size = c(8, 3)
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-set_embedding"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-set_embedding}{}}}
\subsection{Method \code{set_embedding()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$set_embedding(embedding_name, coordinates)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-plot_embedding"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-plot_embedding}{}}}
\subsection{Method \code{plot_embedding()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$plot_embedding(
  embedding_name,
  score = "raw",
  marker_size = 5,
  order_points = FALSE,
  fig_size = c(8, 4),
  color_map = NULL
)}\if{html}{\out{</div>}}
}

}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-pipeline_normalize"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-pipeline_normalize}{}}}
\subsection{Method \code{pipeline_normalize()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$pipeline_normalize(postnorm_total = NULL)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{postnorm_total}}{Target total count after normalization. If not provided, the mean of observed total counts will be used.}
}
\if{html}{\out{</div>}}
}
\subsection{Details}{
Total counts normalization is a step in the preprocessing of single-cell RNA-seq data. It aims to scale the total counts of each cell so that they have a consistent value, making them comparable across cells. This is useful for downstream analyses, such as dimensionality reduction and clustering.

The function updates the normalized observed expression matrix (`E_obs_norm`) based on the specified target total count. If a simulated expression matrix (`E_sim`) is present in the R6 object, it also normalizes the simulated matrix (`E_sim_norm`).
}

\subsection{Returns}{
NULL (modifies the R6 object in place)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-pipeline_get_gene_filter"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-pipeline_get_gene_filter}{}}}
\subsection{Method \code{pipeline_get_gene_filter()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$pipeline_get_gene_filter(
  min_counts = 3,
  min_cells = 3,
  min_gene_variability_pctl = 85
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{min_counts}}{Minimum counts for a gene to be considered highly variable}

\item{\code{min_cells}}{Minimum cells for a gene to be considered highly variable}

\item{\code{min_vscore_pctl}}{Minimum percentile of variance score for a gene to be considered highly variable}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL (modifies the R6 object in place)
Apply gene filter to expression matrices
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-pipeline_apply_gene_filter"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-pipeline_apply_gene_filter}{}}}
\subsection{Method \code{pipeline_apply_gene_filter()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$pipeline_apply_gene_filter()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
NULL (modifies the R6 object in place)
Mean center expression matrix
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-pipeline_mean_center"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-pipeline_mean_center}{}}}
\subsection{Method \code{pipeline_mean_center()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$pipeline_mean_center()}\if{html}{\out{</div>}}
}

\subsection{Returns}{
NULL (modifies the R6 object in place)
Variance Normalization of Expression Matrices

This function performs variance normalization on the observed and simulated expression matrices.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-pipeline_normalize_variance"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-pipeline_normalize_variance}{}}}
\subsection{Method \code{pipeline_normalize_variance()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$pipeline_normalize_variance()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Variance normalization is a step that scales the expression values of each gene across cells based on their standard deviation. It helps to make gene expression distributions comparable between genes.

The function calculates gene standard deviations from the observed expression matrix (`E_obs_norm`). It then scales the observed and simulated matrices based on these standard deviations.
Z-Score Normalization of Expression Matrices

This function performs z-score normalization on the observed and simulated expression matrices.
}

\subsection{Returns}{
NULL (modifies the R6 object in place)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-pipeline_zscore"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-pipeline_zscore}{}}}
\subsection{Method \code{pipeline_zscore()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$pipeline_zscore()}\if{html}{\out{</div>}}
}

\subsection{Details}{
Z-score normalization standardizes the expression values of each gene across cells by subtracting the mean and dividing by the standard deviation. It helps to make gene expression distributions comparable between genes.

The function calculates gene means and standard deviations from the observed expression matrix (`E_obs_norm`). It then applies z-score normalization to the observed and simulated matrices.
Log Transform Expression Matrices

This method performs log transformation on the observed and simulated expression matrices.
}

\subsection{Returns}{
NULL (modifies the R6 object in place)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-pipeline_log_transform"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-pipeline_log_transform}{}}}
\subsection{Method \code{pipeline_log_transform()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$pipeline_log_transform(pseudocount = 1)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{pseudocount}}{The pseudocount added to expression values before taking the logarithm.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL (modifies the R6 object in place)
Truncated Singular Value Decomposition (SVD) for Expression Matrices

This method performs truncated SVD on the observed expression matrix and sets the resulting manifold.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-pipeline_truncated_svd"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-pipeline_truncated_svd}{}}}
\subsection{Method \code{pipeline_truncated_svd()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$pipeline_truncated_svd(
  n_prin_comps = 30,
  random_state = 0,
  algorithm = "arpack"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_prin_comps}}{Number of principal components to keep.}

\item{\code{random_state}}{Seed for reproducibility.}

\item{\code{algorithm}}{Algorithm to use for SVD.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL (modifies the R6 object in place)
Principal Component Analysis (PCA) for Expression Matrices

This method performs PCA on the observed expression matrix and sets the resulting manifold.
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-pipeline_pca"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-pipeline_pca}{}}}
\subsection{Method \code{pipeline_pca()}}{
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$pipeline_pca(
  n_prin_comps = 50,
  random_state = 0,
  svd_solver = "arpack"
)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{n_prin_comps}}{Number of principal components to keep.}

\item{\code{random_state}}{Seed for reproducibility.}

\item{\code{svd_solver}}{Algorithm to use for SVD.}
}
\if{html}{\out{</div>}}
}
\subsection{Returns}{
NULL (modifies the R6 object in place)
}
}
\if{html}{\out{<hr>}}
\if{html}{\out{<a id="method-Scrublet-clone"></a>}}
\if{latex}{\out{\hypertarget{method-Scrublet-clone}{}}}
\subsection{Method \code{clone()}}{
The objects of this class are cloneable with this method.
\subsection{Usage}{
\if{html}{\out{<div class="r">}}\preformatted{Scrublet$clone(deep = FALSE)}\if{html}{\out{</div>}}
}

\subsection{Arguments}{
\if{html}{\out{<div class="arguments">}}
\describe{
\item{\code{deep}}{Whether to make a deep clone.}
}
\if{html}{\out{</div>}}
}
}
}
